import * as fs from 'fs';
import * as path from 'path';
import { Contract } from 'ethers';

export async function generateFrontendFiles(
  contractName: string,
  contract: Contract,
  network: string
) {
  const frontendDir = path.join(__dirname, '../../../frontend/src/contracts');
  
  // Create directories if they don't exist
  if (!fs.existsSync(frontendDir)) {
    fs.mkdirSync(frontendDir, { recursive: true });
  }

  // Generate TypeScript interface for the contract
  const abi = contract.interface.formatJson();
  const types = generateContractTypes(contractName, JSON.parse(abi));
  
  // Write types
  fs.writeFileSync(
    path.join(frontendDir, `${contractName}.ts`),
    types
  );

  // Write ABI
  fs.writeFileSync(
    path.join(frontendDir, `${contractName}.abi.json`),
    abi
  );

  // Update contract addresses
  const addressesPath = path.join(frontendDir, 'contract-addresses.json');
  let addresses = {};
  
  if (fs.existsSync(addressesPath)) {
    addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
  }

  // @ts-ignore
  addresses[network] = {
    // @ts-ignore
    ...addresses[network],
    [contractName]: await contract.getAddress()
  };

  fs.writeFileSync(
    addressesPath,
    JSON.stringify(addresses, null, 2)
  );
}

function generateContractTypes(contractName: string, abi: any[]): string {
  let types = `// Generated by deploy script
import { type Abi } from 'viem'

export type ${contractName}Config = {
  address: \`0x\${string}\`;
  abi: Abi;
}

export type ${contractName}Functions = {
`;

  // Generate function types
  abi.filter(item => item.type === 'function').forEach(func => {
    let argCounter = 1;
    const inputs = func.inputs.map((input: any) => {
      // Special handling for known address parameters
      const paramType = input.type === 'address' ? 
        '`0x${string}`' : 
        convertSolidityTypeToTS(input.type);
      
      // Use input name if available, otherwise use numbered arg
      const paramName = input.name || (argCounter === 1 ? 'arg' : `arg${argCounter}`);
      argCounter++;
      
      return `${paramName}: ${paramType}`;
    }).join(', ');
    
    let outputs = func.outputs?.map((output: any) => {
      // Special handling for known address return types
      if (output.type === 'address') {
        if (['depositToken', 'activityValidator', 'yieldProtocol'].includes(func.name)) {
          return '`0x${string}`';
        }
      }
      return convertSolidityTypeToTS(output.type);
    }).join(' | ') || 'void';

    types += `  ${func.name}(${inputs}): Promise<${outputs}>;\n`;
  });

  types += '}\n\n';

  // Generate event types
  types += `export type ${contractName}Events = {\n`;
  abi.filter(item => item.type === 'event').forEach(event => {
    types += `  ${event.name}: {\n`;
    event.inputs.forEach((input: any) => {
      types += `    ${input.name}: ${convertSolidityTypeToTS(input.type)};\n`;
    });
    types += `  };\n`;
  });

  types += '}\n';

  return types;
}

function convertSolidityTypeToTS(solidityType: string): string {
  if (solidityType.includes('[]')) {
    const baseType = convertSolidityTypeToTS(solidityType.replace('[]', ''));
    return `${baseType}[]`;
  }
  
  const typeMap: { [key: string]: string } = {
    'address': '`0x${string}`',
    'string': 'string',
    'bool': 'boolean',
    'uint256': 'bigint',
    'uint8': 'number',
    'uint': 'bigint',
    'int': 'bigint',
    'bytes32': '`0x${string}`',
    'bytes': 'string',
    'tuple': 'any',
  };

  return typeMap[solidityType] || 'any';
} 